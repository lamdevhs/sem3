<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Asciidoctor 1.5.4">
  <title>Projet : Résolution d’un système linéaire et vérification automatique</title>
  <link rel="stylesheet" href="https://asciidoclive.com/assets/asciidoctor.js/css/asciidoctor.css">
</head>

<body class="article">
  <div id="header">
    <h1>Projet : Résolution d’un système linéaire et vérification automatique</h1>
  </div>
  <div id="content">
    <div id="preamble">
      <div class="sectionbody">
        <div class="paragraph">
          <p>Nathanael Bayard&#8201;&#8212;&#8201;L2 Info&#8201;&#8212;&#8201;2017/2018&#8201;&#8212;&#8201;Méthodes
            Matricielles</p>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_python">Python</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>J’ai choisi la version 2.7 de Python pour écrire la partie 2, afin de garder
            une compatibilité optimale avec les parties 1 et 3, écrites dans <em>Sage</em>.</p>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_linux">Linux</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>Le programme a été écrit sur <em>Xubuntu 16.04</em>, et testé avec succès
            sur l’un des postes d’une des salles de TP.</p>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_notations">Notations</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>Dans ce PDF et dans le code, les notations suivantes relatives au typage
            seront utilisées :</p>
        </div>
        <div class="ulist">
          <ul>
            <li>
              <p>Le symbole <code>:</code> sera utilisé pour définir le type d&#8217;une
                valeur. On notera <code>x : t</code> pour exprimer que <code>x</code>                est du type <code>t</code>. Par exemple : <code>"hello" : String</code>.</p>
            </li>
            <li>
              <p>La signature du type d&#8217;une fonction <code>f(x, y, z)</code> sera
                notée ainsi :</p>
              <div class="listingblock">
                <div class="content">
                  <pre>f : X . Y . Z -&gt; T</pre>
                </div>
              </div>
              <div class="paragraph">
                <p>où <code>X</code>/<code>Y</code>/<code>Z</code> est le type du paramètre
                  <code>x</code>/<code>y</code>/<code>z</code>, et <code>T</code>                  le type de l'<em>output</em> de <code>f</code>.</p>
              </div>
            </li>
            <li>
              <p>Si une fonction produit des effets de bords (<em>side effects</em>),
                on notera son type avec un point d&#8217;exclamation après la flèche,
                ainsi:</p>
              <div class="listingblock">
                <div class="content">
                  <pre>f : X . Y . Z . -&gt; ! T</pre>
                </div>
              </div>
            </li>
            <li>
              <p>En Python, une fonction peut très bien avoir des paramètres étant eux-même
                des fonctions (
                <em>cf</em> <strong>Style de Programmation</strong>). Par exemple
                voici le type de la fonction <code>map</code> :</p>
              <div class="listingblock">
                <div class="content">
                  <pre>map : (a -&gt; b) . List a -&gt; List b</pre>
                </div>
              </div>
            </li>
            <li>
              <p>On peut remarquer que le type de <code>map</code> est polymorphique
                de manière générique : les variables <code>a</code> et <code>b</code>                peuvent représenter n&#8217;importe quel type sans que <code>map</code>                ait besoin d'être modifiée au niveau de son algorithme interne. L&#8217;alignement
                des types (c&#8217;est-à-dire le fait que la variable de type <code>a</code>                dans le type du premier paramètre soit le même que la variable <code>a</code>                dans le type du second paramètre, et <em>idem</em> pour <code>b</code>)
                est tout ce qui compte pour que cela fonctionne.</p>
              <div class="paragraph">
                <p>Certaines fonctions sont cependant polymorphiques <em>ad-hoc</em>:
                  certaines variables de types sont sujettes à des conditions, comme
                  la condition d'être d&#8217;un type qui représente un nombre, que
                  ce soit <code>Integer</code>, <code>Float</code>, <code>Fractional</code>                  ou autre. On notera cette polymorphie de cette manière :</p>
              </div>
              <div class="listingblock">
                <div class="content">
                  <pre>add : [Number a] a . a -&gt; a</pre>
                </div>
              </div>
              <div class="paragraph">
                <p>La fonction <code>add</code> prend deux paramètres de même type <code>a</code>                  quelconque mais qui doit tout de même être un type de <strong>nombre</strong>,
                  et qui retournera une nouvelle valeur du même type <code>a</code>.
                  <code>Number</code> représente une <strong>classe de type</strong>                  ou encore une <strong>contrainte</strong> au sens de <em>Haskell</em>,
                  c&#8217;est-à-dire un ensemble de types restreint pour lesquelles
                  la fonction <code>add</code> fonctionne, et ce de manière polymorphique,
                  ou dit autrement une contrainte sur la polymorphie de la variable
                  de type <code>a</code> dans le type de <code>add</code>.</p>
              </div>
            </li>
            <li>
              <p>Quelques types usuels et leur notation :</p>
              <div class="listingblock">
                <div class="content">
                  <pre>x : a
y : a
z : b
[x, y] : List a
(x, y, z) : (a, b, b)
3 : [Number n] n
"abc" : String</pre>
                </div>
              </div>
            </li>
            <li>
              <p>Quelques <em>aliases</em> qui seront également utilisés et qui permettent
                de différencier par exemple entre le type d&#8217;une liste de nombre
                et le type d&#8217;un vecteur matriciel, même s&#8217;ils ont la
                même valeur (et le même type) pour Python :</p>
              <div class="listingblock">
                <div class="content">
                  <pre>Matrix n = List (List n)
Vector n = List n
Family n = List (Vector n)</pre>
                </div>
              </div>
              <div class="paragraph">
                <p>Je mentionnerai aussi <code>Row n</code> et <code>Column n</code>,
                  tous deux synonymes pour <code>List n</code> et qui représentent
                  respectivement une ligne ou colonne extraite d&#8217;une matrice.
                  Du fait que les matrices sont enregistrées ligne par ligne, on
                  pourrait ainsi aussi écrire :</p>
              </div>
              <div class="listingblock">
                <div class="content">
                  <pre>Matrix n = List (Row n)</pre>
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_style_de_programmation">Style de programmation</h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>J’ai choisi d’adopter un style <strong>purement fonctionnel</strong> autant
            que possible, car je pense que cela permet de raisonner sur le code de
            manière bien plus efficace.</p>
        </div>
        <div class="paragraph">
          <p>Le paradigme <strong>fonctionnel</strong> permet aussi et surtout d’atteindre
            des niveaux d’abstractions plus élevés, qui permettent une réutilisation
            optimale du code ainsi qu’une délégation de tâches répétitives et prones
            aux erreurs, comme la gestion des indices dans des boucles <code>for</code>.</p>
        </div>
        <div class="paragraph">
          <p>Le paradigme <strong>purement</strong> fonctionnel implique que toute variable
            est immutable et sa valeur ne change pas tout au long de la durée de
            vie de la variable. Cela a pour conséquence de ne jamais risquer qu&#8217;une
            fonction modifie la valeur d&#8217;un objet donné en paramètre d&#8217;une
            manière qu&#8217;il serait difficile de suivre ou vérifier.</p>
        </div>
        <div class="paragraph">
          <p>Toute fonction pure étant complètement déterminée par le lien entre <em>input</em>            et <em>output</em>, les test unitaires en sont d&#8217;autant plus faciles
            à réaliser car aucun environnement/état extérieur n&#8217;a besoin d'être
            contrôlé ou simulé par peur de perturbations extérieures sur le fonctionnement
            d&#8217;une telle fonction, qui ne connaît que ce qui lui est donné en
            paramètres, et ne fait que renvoyer une nouvelle valeur de retour.</p>
        </div>
        <div class="paragraph">
          <p>Il faut tout de même admettre qu&#8217;en Python, écrire de manière purement
            fonctionnelle n&#8217;est pas chose aisée. Aussi beaucoup de fonctions
            admettent la modification de variables pourvues que ces modifications
            ne se déroulent que lors de la <strong>construction</strong> de la valeur.
            Par exemple, une implémentation de <code>map</code> pourrait ressembler
            à :</p>
        </div>
        <div class="listingblock">
          <div class="content">
            <pre>def map(f, L):
    out = []
    for x in L:
        out.append(f(x))
    return out</pre>
          </div>
        </div>
        <div class="paragraph">
          <p>La variable <code>out</code> est mutée tout au long de la fonction, mais
            on remarquera que cela correspond bien à la phase de <strong>construction</strong>            de la valeur de sortie, et qu&#8217;aucune valeur donnée en paramètres
            n&#8217;est modifiée.</p>
        </div>
        <div class="paragraph">
          <p>Les outils les plus classiques des langages fonctionnels se révèlent naturellement
            utiles ici : entre autres, <code>map</code>, <code>filter</code>, <code>reduce</code>            (parfois aussi appelé <code>fold</code>) sont utilisés abondament dans
            le programme. Beaucoup de fonctions prennent d’autres fonctions en paramètres
            (en tant que valeurs de première classe), et/ou retournent une fonction
            en <em>output</em>.</p>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="__code_maybe_code_et_code_either_code"><code>Maybe</code> et <code>Either</code></h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>J’ai choisi d’utiliser deux types algébriques très utilisés dans les langages
            dits purement fonctionnels comme <em>Haskell</em> (c’est-à-dire, qui
            évitent autant que possible tout effet de bord ou <em>side effects</em>),
            qui sont les types <code>Maybe</code> et <code>Either</code>, qui permettent
            de gérer élégamment et automatiquement le séquençage d’opérations qui
            chacunes peuvent échouer et donc court-circuiter la série complète d’opération,
            et renvoyer une valeur qui représente une erreur (dans le cas de <code>Maybe</code>),
            ou une valeur représentant un message d’erreur correspondant à la première
            erreur rencontrée (dans le cas de <code>Either</code>). Ces types remplissent
            des rôles équivalents aux <em>exceptions</em> et aux valeurs arbitraires
            renvoyées lorsqu&#8217;une fonction ne peut faire son travail, comme
            lorsqu&#8217;une recherche renvoie <code>-1</code> ou <code>null</code>            en cas d'échec.</p>
        </div>
        <div class="sect2">
          <h3 id="_maybe">Maybe</h3>
          <div class="paragraph">
            <p><code>Maybe</code> est en réalité un <em>constructeur de type</em>, soit
              une fonction dit <em>type-level</em> qui prend un type <code>t</code>              en paramètre et retourne un nouveau type <code>Maybe t</code> en sortie.
              Une valeur <code>x : Maybe t</code> représentera ou bien une valeur
              de type <code>t</code>, ou bien une "erreur" (dans un sens large qui
              dépendra de l&#8217;utilisation).</p>
          </div>
          <div class="paragraph">
            <p>Les valeurs possibles du type <code>Maybe t</code> seront ou bien de
              la forme <code>Just(y)</code> avec <code>y : t</code>, ou bien seront
              la valeur unique et arbitraire dénotée <code>Nothing</code>, qui représente
              la notion d&#8217;erreur. <code>Maybe t</code> est un type qui ne fait
              donc qu&#8217;envelopper (<em>wrapping</em>) de manière transparente
              une valeur d&#8217;un type <code>t</code> quelconque, en ajoutant la
              possibilité qu&#8217;au lieu d&#8217;une valeur <code>Just(y) : Maybe t</code>,
              on ait la valeur <code>Nothing : Maybe t</code>.</p>
          </div>
          <div class="paragraph">
            <p>Tout l&#8217;intérêt de <code>Maybe</code> réside dans deux fonctions
              fondammentales que j&#8217;ai nommé <code>maybeApply</code> et <code>maybeDo</code>.
              Ces fonctions ont été écrites en Python sous la forme de méthodes de
              la classe <code>Maybe</code> principalement pour des raisons de praticité
              syntaxique.</p>
          </div>
          <div class="paragraph">
            <p>Signature de <code>maybeApply</code> (appelée <code>fmap</code> en <em>Haskell</em>):</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre>`maybeApply : Maybe a . (a -&gt; b) -&gt; Maybe b`</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>L&#8217;algorithme interne est trivial et consiste à ne rien faire si
              la valeur du premier paramètre est <code>Nothing</code>. Axiomatiquement
              :</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre>maybeApply(Nothing, f) = Nothing
maybeApply(Just(y), f) = Just(f(y))</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>Signature de <code>maybeDo</code> (appelée <code>bind</code> ou <code>&gt;&gt;=</code>              en <em>Haskell</em>):</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre>`maybeDo : Maybe a . (a -&gt; Maybe b) -&gt; Maybe b`</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>La principale différence entre <code>maybeDo</code> et <code>maybeApply</code>              tient au fait que le second paramètre de <code>maybeDo</code> est une
              fonction qui peut renvoyer <code>Nothing</code>. Algorithme interne
              de <code>maybeDo</code> :</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre>maybeDo(Nothing, f) = Nothing
maybeDo(Just(y), f) = f(y)</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>Exemple d&#8217;utilisation dans mon code :</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre>maybeSystemFromMatrix : [Number n] Matrix n . Vector n -&gt; Maybe (System n)
echelonized           : [Number n] System n -&gt; Maybe (System n)
normalized            : [Number n] System n -&gt; Maybe (System n)
extractSolution       : [Number n] System n -&gt; (Family n, Vector n)

maybeSolution = maybeSystemFromMatrix(matrix, rightSide
        ).maybeDo(echelonized, 0
        ).maybeDo(normalized
        ).maybeApply(extractSolution)</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>La première fonction, <code>maybeSystemFromMatrix</code> renverra ou
              bien <code>Just(system)</code> ou bien <code>Nothing</code>, en fonction
              de la validité des éléments donnés en paramètre. Par la suite, les
              fonction <code>echelonized</code>, <code>normalized</code> et <code>extractSolution</code>              ne seront appelés que si tout s&#8217;est bien passé précédemment.
              Si à un quelconque moment, la valeur <code>Nothing</code> est produite,
              toute la séquence résultera en une valeur de <code>Nothing</code> automatiquement
              et aucune opération subséquente ne sera appliquée. <code>extractSolution</code>              est une fonction qui n'échoue jamais, par conséquent elle est appliquée
              au résultat éventuel des opérations précédentes avec <code>maybeApply</code>.
              Au final, on obtient <code>maybeSolution : Maybe (Family n, Vector n)</code>.</p>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_either">Either</h3>
          <div class="paragraph">
            <p><code>Either</code> est très similaire à un <code>Maybe</code> pour lequel
              la valeur <code>Nothing</code> pourrait contenir une valeur qui servirait
              de message d&#8217;erreur. <code>Either</code> prend deux types en
              paramètres, le type du message d&#8217;erreur attendu et le type de
              la valeur contenue si tout se passe bien (dans cet ordre). On parlera
              par exemple de <code>Either String t</code>, <code>String</code> étant
              le type du message d&#8217;erreur, et <code>t</code> le type de la
              valeur contenue s&#8217;il n&#8217;y a pas d&#8217;erreur.</p>
          </div>
          <div class="paragraph">
            <p>Pour le type <code>Either e a</code>, les <strong>constructeurs</strong>              de valeurs sont respectivement <code>Left(x)</code> avec <code>x : e</code>              et <code>Right(y)</code> avec <code>y : a</code>.</p>
          </div>
          <div class="paragraph">
            <p>Comme pour <code>Maybe</code>, ce type prend toute son utilité lorsqu&#8217;on
              lui associe deux fonctions que j&#8217;ai appelé <code>eitherApply</code>              et <code>eitherDo</code>. Comme dans le cas de <code>maybeApply/Do</code>,
              toute valeur de la forme <code>Left(x) : Either e a</code> ressortira
              inchangée au niveau de sa valeur (bien que son type change depuis <code>Either e a</code>              vers <code>Either e b</code>) :</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre>eitherApply : Either e a . (a -&gt; b) -&gt; Either e b
eitherApply(Left(x), f) = Left(x)
eitherApply(Right(y), f) = Right(f(y))

eitherDo : Either e a . (a -&gt; Either e b) -&gt; Either e b
eitherDo(Left(x), f) = Left(x)
eitherDo(Right(y), f) = f(y)</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>Exemple d&#8217;utilisation de <code>Either</code> dans la fonction <code>eitherSequence</code>:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre>eitherSequence : (a -&gt; Either e b) . List a -&gt; Either e (List b)
def eitherSequence(f, xs):
    out = []
    for x in xs:
        y = f(x)
        if y.isLeft:
            return y
        else:
            out.append(y.rightValue)
    return Right(out)</pre>
            </div>
          </div>
          <div class="paragraph">
            <p>Essentiellement, cette fonction agit comme une fonction <code>map : (a &#8594; b) . List a &#8594; List b</code>              qui supporterait que la fonction donnée en entrée renvoie un message
              d&#8217;erreur au lieu d&#8217;une valeur de type <code>b</code>. Ainsi,
              <code>eitherSequence</code> renvoie <em>ou bien</em> le résultat du
              <em>mapping</em> de la liste d&#8217;entrée par la fonction d&#8217;entrée,
              <em>ou bien</em> le message correspondant à la première erreur rencontrée.</p>
          </div>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_la_classe_code_system_code">La classe <code>System</code></h2>
      <div class="sectionbody">
        <div class="paragraph">
          <p>J&#8217;ai utilisé cette classe pour bien séparer dans l&#8217;algorithme
            de la méthode de Gauss, les lignes sur lesquelles un pivot avait déjà
            été trouvé, et les lignes restantes. Cela permet de ne rechercher le
            prochain pivot que dans les lignes qui ne sont pas "pivotantes". A la
            fin du processus de échelonisation, et si tout s&#8217;est bien passé
            (pas d'équation <code>0 = n</code>, <code>n</code> non nul rencontré),
            les éventuelles lignes "non pivotantes" restantes sont forcément pleines
            de zéroes, et peuvent être ignorées durant les phases suivantes (normalisation
            et extraction de solution).</p>
        </div>
        <div class="paragraph">
          <p>Au début de l&#8217;algorithme, j&#8217;ai choisi de fusionner la matrice
            de gauche avec le vecteur de droite, soit <code>A</code> et <code>Y</code>            dans <code>AX = Y</code>, afin que toute opération sur une ligne de la
            matrice résultante soit effectuée autant sur <code>A</code> que sur <code>Y</code>.
            Evidemment cela a nécessité d'éviter que l&#8217;algorithme ne recherche
            des pivots dans la colonne correspondant au vecteur de droite, mais c&#8217;est
            un moindre mal.</p>
        </div>
      </div>
    </div>
    <div class="sect1">
      <h2 id="_commentaires_concernant_la_partie_3">Commentaires concernant la partie 3</h2>
      <div class="sectionbody">
        <div class="sect2">
          <h3 id="_format_de_sortie_pour_les_solutions_trouv_es_dans_la_partie_2">Format de sortie pour les solutions trouvées dans la partie 2</h3>
          <div class="paragraph">
            <p>Le format choisi pour enregistrer les systèmes et leurs solutions calculées
              dans la partie 2 afin de les comparer avec les solutions trouvées dans
              la partie 1, est, pour l'équation <code>AX = Y</code> le suivant :</p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>Première ligne : série de <em>tokens</em> représentant des nombres
                  fractionnels, espacés les uns des autres, le tout représentant
                  le vecteur de droite de l'équation matricielle, soit <code>Y</code></p>
              </li>
              <li>
                <p>Deuxième ligne : la matrice <code>A</code> enregistrée ligne par
                  ligne, soit une ligne contenant <code>np</code> <em>tokens</em>.
                  Les valeurs <code>n</code> et <code>p</code> sont facilement récupérables
                  puisque on sait que <code>Y</code> contient toujours <code>n</code>                  valeurs.</p>
              </li>
              <li>
                <p>Troisième ligne : la solution particulière trouvée pour l'équation
                  <code>AX = Y</code>, soit <code>q</code> <em>tokens</em>, <code>q</code>                  supérieur ou égal à <code>n</code>.</p>
              </li>
              <li>
                <p>quatrième ligne : les vecteurs de la base du noyau de <code>A</code>                  trouvée, enregistrés les uns après les autres, soit <code>qr</code>                  <em>tokens</em>, avec <code>r = dim ker(A)</code> et bien sûr <code>q</code>                  est le nombre de composantes de la solution particulière enregistrée
                  sur la troisième ligne.</p>
              </li>
              <li>
                <p>cinquième ligne : ligne vide, qui sera de toute façon ignorée par
                  le parser qui lira le fichier, pour plus de lisibilité.</p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>Dans les cas limites : si aucune solution n&#8217;est trouvée (le système
              est insoluble, l&#8217;ensemble des solutions est <code>{}</code>),
              les lignes trois et quatre sont remplies chacunes par l&#8217;unique
              token <code>"NOTHING"</code> (en tant que chaîne de caractère).</p>
          </div>
          <div class="paragraph">
            <p>Si <code>r = dim ker(A) = 0</code>, la quatrième ligne sera automatiquement
              laissée vide puique on aura tout simplement <code>qr = 0</code>.</p>
          </div>
        </div>
        <div class="sect2">
          <h3 id="_comparaisons_des_solutions_trouv_es_selon_les_deux_m_thodes">Comparaisons des solutions trouvées selon les deux méthodes :</h3>
          <div class="paragraph">
            <p>Soit <code>AX = Y</code> l'équation matricielle du système étudié, <code>B1</code>              et <code>B2</code> les familles de vecteurs trouvées dans les parties
              1 et 2 et qui devraientt être des base du noyau de <code>A</code>,
              et <code>S1</code> et <code>S2</code> les vecteur correspondant aux
              solutions particulières trouvées de même dans les parties 1 et 2.</p>
          </div>
          <div class="paragraph">
            <p>Afin de vérifier que les solutions concordent et sont valides, il faut
              vérifier :</p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>que les solutions particulières sont bien valides, c&#8217;est-à-dire,
                  que <code>A*S1 == Y</code> et <code>A*S2 == Y</code></p>
              </li>
              <li>
                <p>que les hypothétiques bases sont libres et de cardinalité identiques
                  à la dimension du noyau trouvé par Sage, et de plus que pour chaque
                  vecteur <code>u</code> dans <code>B1</code> et <code>B2</code>,
                  on ait <code>A*u = 0</code>, c&#8217;est-à-dire, que <code>u</code>                  est bien dans <code>ker(A)</code>.</p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>L&#8217;unicité du noyau garantira alors l&#8217;unicité des solutions
              trouvées par les deux méthodes.</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>

</html>